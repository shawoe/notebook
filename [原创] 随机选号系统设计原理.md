## 随机选号系统设计原理 ##

最近在做一个项目，用户注册时需要返回一组随机卡号，由用户选择自己喜欢的卡号进行注册，比腾讯人性化很多。要求是在500W个可用卡号内，为每个注册的用户提供不重复的随机20个卡号，供用户选择，并返回用户选择的卡号作为该用户的唯一标识。下面介绍一下我们的开发思路：

### 伪随机策略：提高数据库空间效率 ###

首先，业务上总共500W个卡号可供用，每个用户有20个卡号可供选择，且是不重复的随机卡号。如果一次性将500W个卡号全部存入数据库，将大量占用数据库内存，空间效率很低，CRUD速率下降，时间效率也降低。

通过分析，该网站未来可预期的一段时间内，在线人数峰值<500，因此，同一时段内注册人数远小于500，所以10000个卡号就可以满足最大负载。

虽然需要的是完全随机卡号，但其实相对随机就足够了，只需让用户看到的那20个卡号是随机的，因此先存入该500W个卡号的前10000个卡号，其余卡号作为候补卡号。

每当用户选择了一个卡号，将其余19个卡号归还，用递增的候补卡号替换被选中的卡号。例如A用户取出了0~19这20个卡号，选中16号，其余归还，将10001替换16号。这样维持10000个卡号总数，同时也维持了乱序。

### 状态位：临界资源的加锁实现 ###

将10000个账号顺序打乱，存入数据库。我们来考虑一个问题，假设A用户已经取出了0~19这20个卡号，但只选择其中一个卡号，其余的归还，而与此同时B用户也取出了0~19这20个卡号，就有可能与A用户选择了同一个号。

这是一个多线程环境下的互斥操作，A用户取出的20个号是临界资源，需要设置一个字段为状态位，判断该卡号是否已被取出(0,1)。

### 分组建立索引：算法的优化 ###

再考虑一个问题，如果取出的20个卡号中每一个卡号都是随机选取的，那就需要对每一个取出的卡号设置状态位，并且每一个卡号都需要判断其是否已经被取出，这样的算法显然是低效的。

深入挖掘一下这个问题，10000个卡号我们分成20组（每个用户只需要取出20个卡号），我们以第一组为索引，取号时取第一组的某一个卡号，就可以根据该卡号在第一组的相对位置，加上组间距500，获取其他19个组相对位置的卡号，从而获得了20个随机卡号。例如，选中第一组第n个，就可以选择第二组第n个，即：等差数列n,n+500,n+500*2……

在取号时，分配策略按顺序循环选取第一组中的卡号（当然也可以随机选取），通过判断第一组该卡号的状态位，就可以得知其余19组中相对位置卡号的状态，优化了大量的判断操作和状态位变更操作。若该卡号已经被取出，则继续循环选择下一个（或者随机选择下一个）。

### 解铃还须系铃人：伪随机VS完全随机 ###

我们深入的挖掘一下问题的本质，我们为什么需要随机卡号。随机卡号只是为了给用户更好的体验（被忽悠得心情愉快），在用户看来有随机的选择权。

而在用户看来，500W个卡号中的20个随机卡号和10000个卡号中的20个随机卡号，是没有区别的。而将10000+的卡号替换原位置的被选卡号，仍然能够保证数据库中10000个卡号是乱序的。

分组策略中，虽然每一组中19个卡号没有得到更新，但正常情况下，每一个用户一般只注册一到两次，看见同一组数发现随机卡号没有变化的概率几乎为0.

### 内存中号池的建立：实践是检验真理的唯一标准 ###

如何打乱10000个卡号，先顺序存入数据库再打乱显然是不合理的，对数据库频繁的读写效率很低，而且有些数据库可能会锁表。

显然，我们应该在内存中进行操作，于是我们引入了一个号池的概念，创建了单例类CardGenerator，实现卡号的提取，新旧卡号替换的功能。单例的写法网上有一篇很不错的文章，这里就不多说了。

JAVA单例写法参考链接：[http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)

取号是通过一个栈来存储组数，后来改成了队列，因为队列是线程安全的，通过栈的出入操作来取组数。

### 拦截器：吉祥卡号与正则表达式 ###

卡号中有一些特殊的卡号是吉祥卡号，这些吉祥卡号都是给VIP的，我们需要一个函数将他们抽取出来，很自然的想到了正则。

正则表达式教程：[http://www.java3z.com/cwbwebhome/article/article8/Regex/Java.Regex.Tutorial.html](http://www.java3z.com/cwbwebhome/article/article8/Regex/Java.Regex.Tutorial.html)

吉祥卡号检测规则：主要可以检测连号（正连 12345、倒连 65432）、AABB号、手机号码、日期号（生日号、年度号）、ABBCABB号，3位以上重复号。更多类型号码检测可以根据以下表达式改造。

	// 匹配6位顺增
	regex.Pattern = "(?:0(?=1)|1(?=2)|2(?=3)|3(?=4)|4(?=5)|5(?=6)|6(?=7)|7(?=8)|8(?=9)){5}\d"

	// 匹配6位顺降
	regex.Pattern = "(?:9(?=8)|8(?=7)|7(?=6)|6(?=5)|5(?=4)|4(?=3)|3(?=2)|2(?=1)|1(?=0)){5}\d"

	// 匹配6位顺增或顺降
	regex.Pattern = "(?:(?:0(?=1)|1(?=2)|2(?=3)|3(?=4)|4(?=5)|5(?=6)|6(?=7)|7(?=8)|8(?=9)){5}|(?:9(?=8)|8(?=7)|7(?=6)|6(?=5)|5(?=4)|4(?=3)|3(?=2)|2(?=1)|1(?=0)){5})\d"

	// 匹配4-9位连续的数字
	regex.Pattern = "(?:|(?:0(?=1)|1(?=2)|2(?=3)|3(?=4)|4(?=5)|5(?=6)|6(?=7)|7(?=8)|8(?=9)){3,}(?:9(?=8)|8(?=7)|7(?=6)|6(?=5)|5(?=4)|4(?=3)|3(?=2)|2(?=1)|1(?=0)){3,})\d"

	// 匹配3位以上的重复数字
	regex.Pattern = "([\d])\1{2,}"

	// 匹配日期类型的数字
	regex.Pattern = "(19|20)[\d]{2}(1[0-2]|0?[1-9])(31|2[0-9]|1[0-9]|0?[0-9])"

	// 手机号码
	regex.Pattern = "(13[0-9]|15[0-9]|18[0-9])([\d]{2,4}){2}"

	// 匹配 33111 类型
	regex.Pattern = "([\d])\1{1,}([\d])\2{2,}"

	// 匹配 5331533 类型
	regex.Pattern = "(([\d]){1,}([\d]){1,})\1{1,}"

	// 匹配 22334 123355 类型
	regex.Pattern = "([\d])\1{1,}([\d])\2{1,}"





